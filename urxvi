#! perl

use File::Basename;

use constant {
  MK_SHIFT   => 0x00010000,
  MK_CONTROL => 0x00020000,
  MK_MOD4    => 0x00040000,
  MK_ALT     => 0x00080000,
};

# Author: Chip Camden <sterling@camdensoftware.com>

sub on_user_command {
  my ($self, $cmd) = @_;
  if ($cmd =~ s/^urxvi\b//) {
    if ($self->{urxvi}) {
      $self->{urxvi} = ();
    } else {
      my $urxvi = {};
      my $status = {};
      $status->{rend} = urxvt::OVERLAY_RSTYLE;
      $status->{window} = $self->overlay(
			     0, 0, $self->ncol, 1, $status->{rend}, 0
			     );

      $urxvi->{status} = $status;
      $urxvi->{select_mode} = '';
      $self->{urxvi} = $urxvi;
      $self->update();
    }
  }
  ()
}

sub on_key_press {
  my ($self, $event, $keysym) = @_;
  my $urxvi = $self->{urxvi};
  if ($urxvi) {
    $self->debug_out(sprintf("keypress: %04x\n", $keysym));
    $self->{last_event} = $event;
    if ($keysym > 0xffe0) {
      $self->{metakeys} |= $self->metacode($keysym);
    } else {
      my $meta = $self->{metakeys};
      $meta &= ~MK_SHIFT if ($keysym <= 0xff);
      $keysym |= $meta;
      $self->eval_key($keysym);
    }
    return 1;
  }
  ()
}

sub on_key_release {
  my ($self, $event, $keysym) = @_;
  if ($keysym > 0xffe0) {
    $self->{metakeys} &= ~($self->metacode($keysym));
  }
  $self->{urxvi};
}

sub eval_key {
  my ($self, $keysym) = @_;
  $self->{repeat_touched} = 0;
  my $keyhandler = $self->{onkeypress};
  my $handled = 0;
  if ($keyhandler) {
    my ($context, $body) = @$keyhandler;
    my $func = $context->eval($body);
    $handled = $context->$func($keysym);
  }
  if (!$handled) {
    if (my $keymap = $self->{keymap}->{"$keysym"}) {
      my ($context, $cmd) = @$keymap;
      $context->eval($cmd);
    } else {
      $self->scr_bell();
    }
  }
  # if the command didn't set repeat count, clear it.
  $self->{repeat} = 0 if !($self->{repeat_touched});
  $self->update();
}

sub metacode {
  my ($self, $keysym) = @_;
  if (($keysym == 0xffe1) || ($keysym == 0xffe2)) {
    MK_SHIFT;
  } elsif (($keysym == 0xffe3) || ($keysym == 0xffe4)) {
    MK_CONTROL;
  } elsif ($keysym == 0xffeb) {
    MK_MOD4;
  } elsif (($keysym == 0xffe9) || ($keysym == 0xffea)) {
    MK_ALT;
  } else {
    0;
  }
}

sub update {
  my ($self) = @_;
  my $urxvi = $self->{urxvi};
  if ($urxvi)
  {
    my ($crow, $ccol) = $self->screen_cur();
    my $status = $urxvi->{status};
    my $w = $status->{window};
    my $sts = "urxvi | ";
    my $rrow = $crow - $self->top_row + 1;
    $sts .= "$crow($rrow),$ccol";
    if ($urxvi->{select_mode}) {
       my ($srow, $scol) = @{ $urxvi->{select_anchor} };
       my ($brow, $bcol, $erow, $ecol) =
          (($srow < $crow) || (($srow == $crow) && ($scol <= $ccol))) ?
          ($srow, $scol, $crow, $ccol) :
	  ($crow, $ccol, $srow, $scol);
       if ($urxvi->{select_mode} eq 'line') {
         $bcol = 0;
	 $ecol = $self->ncol-1;
       }
       $self->selection_beg($brow, $bcol);
       $self->selection_end($erow, $ecol);
       $self->selection_make($self->{last_event}->{time});
       $sts .= " | Select $brow,$bcol..$erow,$ecol";
    }
    $sts .= " | Repeat: $self->{repeat}" if $self->{repeat};
    my $rem = $self->ncol - $self->strwidth($sts);
    $sts .= (' ' x $rem) if $rem > 0;
    $w->set(0,0,$sts);
    $w->show();
    $self->want_refresh();
  }
}

sub my_resource {
  my ($self, $name) = @_;
  $self->x_resource ("$self->{name}.$name");
}

sub on_start {
  my ($self) = @_;

  ($self->{name} = __PACKAGE__) =~ s/.*:://;
  $self->{name} =~ tr/_/-/;
  $self->{urxvi} = ();
  $self->{debug} = ($self->my_resource("debug") eq "on");
  $self->{debug_indent} = '';
  $self->define_functions();
  $self->define_keynames();
  $self->{metakeys} = 0;
  $self->{keymap} = {};
  $self->source(dirname(__FILE__) . "/urxvirc");
  $self->source($self->my_resource("rcfile") || "~/.urxvirc");
  $self->{repeat} = 0;		# repeat count for commands
  $self->{onkeypress} = ();
}

sub define_keynames {
  my ($self) = @_;
  my $k = {};
  $k->{BS} = 0xff08;
  $k->{Tab} = 0xff09;
  $k->{NL} = 0xff0a;
  $k->{FF} = 0xff0c;
  $k->{CR} = 0xff0d;
  $k->{Return} = 0xff0d;
  $k->{Enter} = 0xff0d;
  $k->{Esc} = 0xff1b;
  $k->{Space} = 0x20;
  $k->{Del} = 0xffff;
  $k->{Up} = 0xff52;
  $k->{Down} = 0xff54;
  $k->{Left} = 0xff51;
  $k->{Right} = 0xff53;
  for (1..12) {
    $k->{"F$_"} = 0xffbd + $_;
  }
  $k->{Insert} = 0xff63;
  $k->{Home} = 0xff50;
  $k->{End} = 0xff57;
  $k->{PageUp} = 0xff55;
  $k->{PageDown} = 0xff56;
  $k->{kHome} = 0xff95;
  $k->{kEnd} = 0xff9c;
  $k->{kPageUp} = 0xff9a;
  $k->{kPageDown} = 0xff9b;
  $k->{kPlus} = 0xffab;
  $k->{kMinus} = 0xffad;
  $k->{kMultiply} = 0xffaa;
  $k->{kDivide} = 0xffaf;
  $k->{kEnter} = 0xff8d;
  $k->{kPoint} = 0xffae;
  for (0..9) {
    $k->{"k$_"} = 0xffb0 + $_;
  }

  # Special bit flags for metakeys
  $k->{"S-"} = MK_SHIFT;
  $k->{"C-"} = MK_CONTROL;
  $k->{"M-"} = MK_MOD4;
  $k->{"A-"} = MK_ALT;
  $self->{keynames} = $k;
}

sub define_functions {
  my ($global_self) = @_;
  my $functions = {};
  $functions->{'+'} = sub {
    my $self = shift;
    my $result = 0;
    for (@_) {
      $result += $self->eval($_);
    }
    $result;
  };
  $functions->{'-'} = sub {
    my $self = shift;
    my $result = $self->eval(shift);
    for (@_) {
      $result -= $self->eval($_);
    }
    $result;
  };
  $functions->{'*'} = sub {
    my $self = shift;
    my $result = $self->eval(shift);
    for (@_) {
      $result *= $self->eval($_);
    }
    $result;
  };
  $functions->{'/'} = sub {
    my $self = shift;
    my $result = $self->eval(shift);
    for (@_) {
      $result /= $self->eval($_);
    }
    $result;
  };
  $functions->{'^'} = sub {
    my ($self, $row) = @_;
    if (!$row) {
      ($row) = $global_self->screen_cur;
    }
    my $text = $global_self->ROW_t($row);
    my $ccol;
    for ($ccol = 0;
         ($ccol < $global_self->ncol) && (substr($text,$ccol,1) =~ /[\s\t\x{FFFF}]/);
	 $ccol++)
	 {}
    $ccol = 0 if ($ccol >= $global_self->ncol);
    $ccol;
  };
  $functions->{'$'} = sub {
    my ($self, $row) = @_;
    if (!$row) {
      ($row) = $global_self->screen_cur;
    }
    my $text = $global_self->ROW_t($row);
    my $ccol;
    for ($ccol = $global_self->ncol-1;
	 ($ccol > 0) && (substr($text,$ccol,1) =~ /[\s\t\x{FFFF}]/);
	 $ccol--)
	 {}
    $ccol;
  };
  $functions->{and} = sub {
    my $self = shift;
    my $rval = $self;
    for (@_) {
      last if !($rval &&= $self->eval($_));
    }
    $rval;
  };
  $functions->{bind} = sub {
    my ($self, $key, $cmd) = @_;
    my $keysym = $global_self->translate_keyname($self->eval($key));
    my @keymap = ($self, $cmd);
    $global_self->{keymap}->{"$keysym"} = \@keymap;
  };
  $functions->{call} = sub {
    my $self = shift;
    my $func = $self->eval(shift);
    $global_self->debug_out($func);
    $self->$func(@_);
  };
  $functions->{cursor_row} = sub {
    my $self = shift;
    my ($crow, $ccol) = $global_self->screen_cur;
    $crow;
  };
  $functions->{cursor_column} = sub {
    my $self = shift;
    my ($crow, $ccol) = $global_self->screen_cur;
    $ccol;
  };
  $functions->{def} = sub {
    my ($self, $name, $args, @body) = @_;
    $self->{functions}->{$name} = $self->make_func($args, @body);
  };
  $functions->{eq} = sub {
    my $self = shift;
    $self->eval(shift) eq $self->eval(shift);
  };
  $functions->{first_row} = sub { $global_self->top_row; };
  $functions->{ge} = sub {
    my $self = shift;
    $self->eval(shift) ge $self->eval(shift);
  };
  $functions->{gt} = sub {
    my $self = shift;
    $self->eval(shift) gt $self->eval(shift);
  };
  $functions->{if} = sub {
    my ($self, $cond, $iftrue, $iffalse) = @_;
    ($self->eval($cond)) ? ($self->eval($iftrue)) : ($self->eval($iffalse))
  };
  $functions->{lambda} = sub {
    my ($self, $args, @body) = @_;
    $self->make_func($args, @body);
  };
  $functions->{last_column} = sub { $global_self->ncol-1; };
  $functions->{last_row} = sub { $global_self->nrow - 1; }; 
  $functions->{le} = sub {
    my $self = shift;
    $self->eval(shift) le $self->eval(shift);
  };
  $functions->{lt} = sub {
    my $self = shift;
    $self->eval(shift) lt $self->eval(shift);
  };
  $functions->{max} = sub {
    my $self = shift;
    my $result = $self->eval(shift);
    for (@_) {
      my $next = $self->eval($_);
        $result = $next if ($next > $result);
    }
    $result;
  };
  $functions->{min} = sub {
    my $self = shift;
    my $result = $self->eval(shift);
    for (@_) {
      my $next = $self->eval($_);
        $result = $next if ($next < $result);
    }
    $result;
  };
  $functions->{move} = sub {
    my $self = shift;
    my $nrows = $self->eval(shift);
    my $ncols = $self->eval(shift);
    my ($crow,$ccol) = $global_self->screen_cur;
    if ($nrows) {
      my $new_row = $crow + $nrows;
      if ($new_row >= $global_self->nrow) {
        $new_row = $global_self->nrow-1;
      } elsif ($new_row < $global_self->top_row) {
        $new_row = $global_self->top_row;
      }
      if ($new_row <= $global_self->view_start) {
	$global_self->view_start($new_row-1);	# keep one above us
      } elsif ($new_row >= ($global_self->view_start + $global_self->nrow)) {
	$global_self->view_start($new_row - ($global_self->nrow - 1));
      }
      $crow = $new_row;
    }
    if ($ncols) {
      my $new_col = $ccol + $ncols;
      if ($new_col < 0) {
        $new_col = 0;
      } elsif ($new_col >= $global_self->ncol) {
        $new_col = $global_self->ncol-1;
      }
      $ccol = $new_col;
    }
    $global_self->screen_cur($crow, $ccol);
    \($crow, $ccol);
  };
  $functions->{ne} = sub {
    my $self = shift;
    $self->eval(shift) ne $self->eval(shift);
  };
  $functions->{not} = sub {
    my $self = shift;
    !($self->eval(shift));
  };
  $functions->{onkeypress} = sub {
    my ($self, $lambda) = @_;
    my $prev = $global_self->{onkeypress};
    if ($lambda) {
      my @keyhandler = ($self, $lambda);
      $global_self->{onkeypress} = \@keyhandler;
    } else {
      $global_self->{onkeypress} = ();
    }
    @$prev[1] if $prev;
  };
  $functions->{or} = sub {
    my $self = shift;
    my $rval;
    for (@_) {
      last if ($rval ||= $self->eval($_));
    }
    $rval;
  };
  $functions->{page_size} = sub { $global_self->nrow; };
  $functions->{posx} = sub {
    my $self = shift;
    my $col = $self->eval(shift);
    my ($crow, $ccol) = $global_self->screen_cur;
    my $text;
    if (($col >= 0) && ($col < $global_self->ncol)) {
      $ccol = $col;
    } else {
      $global_self->scr_bell;
    }
    $global_self->screen_cur($crow,$ccol);
    \($crow,$ccol);
  };
  $functions->{posy} = sub {
    my $self = shift;
    my $row = $self->eval(shift);
    my $success = ($row);
    if (($row < $global_self->top_row) ||
        ($row >= $global_self->nrow)) {
      $global_self->scr_bell;
      $success = ();
    } else {
      my ($crow, $ccol) = $global_self->screen_cur;
      my $vrow = $global_self->view_start;
      my $max = $row - 1;
      my $min = $row - ($global_self->nrow - 1);
      if ($vrow > $max) {
        $global_self->view_start($max);
      } elsif ($vrow < $min) {
        $global_self->view_start($min);
      }
      $global_self->screen_cur($row, $ccol);
      $success = \($row,$ccol);
    }
    $success;
  };
  $functions->{progn} = sub {
    my $self = shift;
    my $result;
    for (@_) {
      $result = $self->eval($_);
    }
    $result;
  };
  $functions->{push_input} = sub {
    my $self = shift;
    for (@_) {
      my $keys = $self->eval($_);
      while ($keys =~ s/(<.+?>|.)//) {
        my $keysym = $global_self->translate_keyname($1);
	$global_self->eval_key($keysym) if $keysym;
      }
    }
    \@_;
  };
  $functions->{push_key} = sub {
    my $self = shift;
    for (@_) {
      $global_self->eval_key($self->eval($_));
    }
    \@_;
  };
  $functions->{push_repeat} = sub {
    my $self = shift;
    my $digit = $self->eval(shift);
    $global_self->{repeat} = ($global_self->{repeat} * 10) + $digit;
    $global_self->{repeat_touched} = 1;
    $global_self->{repeat};
  };
  $functions->{quit} = sub { $global_self->{urxvi} = (); 1;};
  $functions->{repeat} = sub {
    my ($self, $new) = @_;
    my $old = $global_self->{repeat};
    if ($new) {
      $global_self->{repeat} = $self->eval($new);
      $global_self->{repeat_touched} = 1;
    }
    $old;
  };
  $functions->{select} = sub {
    my $self = shift;
    my $urxvi = $global_self->{urxvi};
    $urxvi->{select_mode} = '';
    my @args = map {$self->eval($_)} @_;
    if ((scalar @args) < 4) {
      @args = ();
      $global_self->selection_clear();
    } else {
      $global_self->selection_beg((@args[0], @args[1]));
      $global_self->selection_end((@args[2], @args[3]));
      $global_self->selection_make($global_self->{lastevent}->{time});
    }
    \@args;
  };
  $functions->{select_mode} = sub {
    my $self = shift;
    my $urxvi = $global_self->{urxvi};
    my $old = $urxvi->{select_mode};
    my $new = shift;
    if (defined($new)) {
      if ($new = $self->eval($new)) {
	my @anchor = $global_self->screen_cur;
	$urxvi->{select_anchor} = \@anchor;
      }
      $urxvi->{select_mode} = $new;
    }
    $old;
  };
  $functions->{selection} = sub { $global_self->selection };
  $functions->{source} = sub { my $self = shift; $global_self->source(map {$self->eval($_)} @_) };
  $functions->{view_start} = sub { $global_self->view_start; };
  $global_self->{functions} = $functions;
}

sub make_func {
  my ($self, $args, @body) = @_;
  my @params = ();
  while ($args =~ s/[ (]*(\w+)[ )]*//) {
    push @params, $1;
  }
  sub {
    my @args = @_;
    my $self = shift @args;
    my $context = {};
    bless $context;
    $context->{functions} = {};
    $context->{prev_context} = $self;
    if ($self->{debug}) {
      $context->{debug} = $self->{debug};
      $context->{debug_indent} = $self->{debug_indent};
    }
    for (@params) {
      my $arg = shift @args;
      $self->debug_out("$_ => $arg\n");
      $context->{functions}->{$_} = sub { $self->eval($arg) };
    }
    my $rval;
    for (@body) {
      $rval = $context->eval($_);
    }
    $rval;
  }
}

sub translate_keyname {
  my ($self, $key) = @_;

  if ($key =~ /^<(.+)>$/) {
    $self->symbolic_keyname($1);
  } else {
    ord($key);
  }
}

sub symbolic_keyname {
  my ($self, $key) = @_;
  if ($key =~ /([SCMA]-)(.+)/) {
    $self->{keynames}->{"$1"} | $self->symbolic_keyname($2);
  } else {
    $self->{keynames}->{"$key"} || ord($key);
  }
}

sub source {
  my ($self, $file, $complain) = @_;
  if (open(my $fh, "<", glob($file))) {
    my $line = 0;
    while (<$fh>) {
      $line++;
      chomp;
      $self->eval($_, $file, $line, $fh);
    }
    close $fh;
    $self;
  } elsif ($complain) {
    warn "urxvi: Cannot open: $file";
    ()
  }
}

sub eval {
  my ($self, $cmd, $file, $line, $stream) = @_;
  my @tokens = ();
  $file ||= 'Error';
  $line ||= '';
  my $paren = 0;
  my @curr_token = ();
  $self->debug_indent;
  do {
    $self->debug_out("eval: $cmd\n");
    while ($cmd =~ s/^\s*((['"]).*?\2|\(|\)|#|\S[^\s#()]*)//) {	# consume a token
      my $token = $1;
      last if ($token eq '#');			# comment
      if ($token eq '(') {			# parenthesized expression
	$paren++;
      } elsif ($token eq ')') {
	$paren--;
      }
      push @curr_token, $token;
      if (!$paren) {
	push @tokens, join(' ', @curr_token);
	@curr_token = ();
      }
    }
  } while (($paren > 0) && $stream && ($cmd = <$stream>) && (chomp $cmd) && $line++);
  warn "urxvi: $file:$line Mismatched parentheses" if $paren;
  my $result;
  $cmd = shift @tokens;
  if (defined($cmd)) {
    if ($cmd =~ /^\((.+)\)$/) {
      $cmd = $self->eval($1);
    } 
    if (my $func = $self->lookup_function($cmd)) {
      $result = $func->($self, @tokens);
    } else {
      $cmd =~ s/^(['"])(.*)\1$/\2/; 		# unquote, if quoted
      $result = $cmd;		# Not a function, just return the token
    }
  }
  $self->debug_out("\x{2514}\x{2500}\x{2500}\x{2500}> $result\n");
  $self->debug_outdent;
  $result;
}

sub lookup_function {
  my ($self, $cmd) = @_;
  my $prev;
  $self->{functions}->{$cmd} ||
    (($prev = $self->{prev_context}) ?
      $prev->lookup_function($cmd) :
      ());
}

sub debug_out {
  my $self = shift;
  print "urxvi:$self->{debug_indent}@_" if $self->{debug};
}

sub debug_indent {
  my $self = shift;
  if ($self->{debug}) {
    $self->{debug_indent} .= (length($self->{debug_indent}) > 0) ? "\x{2502}" : ' ';
  }
}

sub debug_outdent {
  my $self = shift;
  $self->{debug_indent} = substr($self->{debug_indent}, 0, -1) if $self->{debug};
}

# vim:set sw=3 sts=3 et:
