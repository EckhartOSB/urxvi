# Default key bindings for urxvi

# define map in terms of bind
(def map(key input)
  (bind key
    (push_input input)))

# repeat count:
bind 0 (or
         (push_repeat 0)
	 (posx 0))

each (range 1 9) (lambda(n)
		   (bind n (push_repeat n)))

# cursor movement:

# functions that apply the repeat count
(def horz(cols)
  (move 0 
   (* 
     (or repeat 1)
     cols)))

(def vert(rows)
  (move 
    (* 
      (or repeat 1)
      rows)))

bind h (horz -1)
bind j (vert 1)
bind k (vert -1)
bind l (horz 1)
map <Up> k
map <Down> j
map <Left> h
map <Right> l

bind G (and
         (posy
	   (if repeat
	     (+ repeat
	       (- first_row 1))
	     last_row))
	 (posx ^))

bind H (and
	 (posy
	   (+ view_start 1))
	 (posx ^))

bind L (and
	 (posy
	   (+
	     view_start
	     (- page_size 1)))
	 (posx ^))

bind '^' (posx ^)
bind '$' (posx $)

bind '+' (and
	   (vert 1)
	   (posx ^))

bind '-' (and
	   (vert -1)
	   (posx ^))

map <Return> '+'

bind <Home> (posy first_row)
bind <End> (posy last_row)

bind <C-b> (vert
	     (- 2 page_size))

bind <C-f> (vert
	     (- page_size 2))

map <PageUp> <C-b>
map <PageDown> <C-f>

bind <C-u> (vert
	     (/
	       (- 2 page_size)
	       2))

bind <C-d> (vert
	     (/
	       (- page_size 2)
	       2))

# find with repeat count
(def fwr(find pattern)
  (let ((loop (lambda(n)
	        (if (ne n 0)
	          (apply find pattern
	            (call loop (- n 1)))))))
       (call loop (or repeat 1))))

bind w (cursor_pos (fwr 'find_forward' '(?<!\w)\w'))	# Word character, not preceded by word character
bind b (cursor_pos (fwr 'find_backward' '(?<!\w)\w'))
bind W (cursor_pos (fwr 'find_forward' '(?<!\S)\S'))	# Non-space, not preceded by non-space
bind B (cursor_pos (fwr 'find_backward' '(?<!\S)\S'))
bind e (cursor_pos (fwr 'find_forward' '\w(?!\w)'))	# Word character, not followed by word character
bind E (cursor_pos (fwr 'find_forward' '\S(?!\S)'))	# Non-space, not followed by a non-space

# selection
(def toggle_select(mode)
  (select_mode
    (if select_mode '' type)))			# toggle the specified mode

bind v (toggle_select 'char')
bind V (toggle_select 'line')

bind y (if select_mode
           (select_mode '')			# in select mode, just turn it off
	   (progn				# otherwise,
	     (repeat repeat)			# keep the repeat count for later
	     (let ((old_keypress		# save current keypress event
	       (on keypress			# hook the next key
	         (lambda(key)
		   (on keypress old_keypress)	# restore previous event handler
		   (if (eq key 0x79)		# y
		     (select			# select lines
		       cursor_row		# begin with the current line
		       0			# leftmost column
		       (min
		         last_row		# not beyond last row
		         (+ 
			   cursor_row		# use repeat count for number of rows
			   (-
			     (or repeat 1)
			     1)))
		       last_column)		# full width
		     (progn			# if not y,
		       (select_mode 'char')	# turn on select mode
		       (push_key key)		# do the key
		       (select_mode '')))	# turn select mode off
		   1)))))))			# key handled

# miscellaneous
bind q quit

bind <Esc> (if select_mode
             (select_mode '')	# escape select mode
	     (if selection
	       select		# or clear any selection
	       quit))		# or quit urxvi altogether

# command mode
(def ask (prompt action default)
  (cmd_prompt prompt)
  (cmd_text default)
  (cmd_pos 0xFFFF)				# end of default
  (cmd_insert_mode 1)
  (cmd_action action)
  (cmd_mode 1))

cmd_bind <Enter> (progn (call cmd_action cmd_text)
		        (cmd_mode 0))
cmd_bind <Left> (cmd_pos (- cmd_pos 1))
cmd_bind <Right> (cmd_pos (+ cmd_pos 1))
cmd_bind <BS> (if (eq cmd_pos 0)
		  (if (eq (length cmd_text) 0)
		      (cmd_mode 0))		# BS out of command mode
		  (let ((old_pos cmd_pos))
		    (cmd_pos (- cmd_pos 1))
		    (cmd_text
		      (if (gt cmd_pos 0)
		        (format "%s%s"
			  (substr cmd_text 0 cmd_pos)
			  (substr cmd_text old_pos))
			(substr cmd_text old_pos)))))
